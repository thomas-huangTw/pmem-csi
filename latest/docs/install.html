

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Installation and Usage &mdash; PMEM-CSI  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Develop and contribute" href="DEVELOPMENT.html" />
    <link rel="prev" title="Design and architecture" href="design.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PMEM-CSI
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../README.html">Introduction to PMEM-CSI for Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design and architecture</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Installation and Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#software-required">Software required</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hardware-required">Hardware required</a></li>
<li class="toctree-l3"><a class="reference internal" href="#persistent-memory-pre-provisioning">Persistent memory pre-provisioning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#installation-and-setup">Installation and setup</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#install-pmem-csi-driver">Install PMEM-CSI driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#install-using-the-operator">Install using the operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#install-from-source">Install from source</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expose-persistent-and-cache-volumes-to-applications">Expose persistent and cache volumes to applications</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kata-containers-support">Kata Containers support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ephemeral-inline-volumes">Ephemeral inline volumes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#raw-block-volumes">Raw block volumes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enable-scheduler-extensions">Enable scheduler extensions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pmem-csi-deployment-crd">PMEM-CSI Deployment CRD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#deployment">Deployment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#deploymentspec">DeploymentSpec</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deploymentstatus">DeploymentStatus</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#filing-issues-and-contributing">Filing issues and contributing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DEVELOPMENT.html">Develop and contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="autotest.html">Automated testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/readme.html">Application examples</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/intel/pmem-csi">Project GitHub repository</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PMEM-CSI</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Installation and Usage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="installation-and-usage">
<h1>Installation and Usage<a class="headerlink" href="#installation-and-usage" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="#prerequisites">Prerequisites</a></p>
<ul>
<li><p><a class="reference external" href="#software-required">Software required</a></p></li>
<li><p><a class="reference external" href="#hardware-required">Hardware required</a></p></li>
<li><p><a class="reference external" href="#persistent-memory-pre-provisioning">Persistent memory pre-provisioning</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#installation-and-setup">Installation and setup</a></p>
<ul>
<li><p><a class="reference external" href="#install-pmem-csi-driver">Install PMEM-CSI driver</a></p>
<ul>
<li><p><a class="reference external" href="#install-using-the-operator">Install using the operator</a></p></li>
<li><p><a class="reference external" href="#install-from-source">Install from source</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#expose-persistent-and-cache-volumes-to-applications">Expose persistent and cache volumes to applications</a></p></li>
<li><p><a class="reference external" href="#kata-containers-support">Kata Containers support</a></p></li>
<li><p><a class="reference external" href="#ephemeral-inline-volumes">Ephemeral inline volumes</a></p></li>
<li><p><a class="reference external" href="#raw-block-volumes">Raw block volumes</a></p></li>
<li><p><a class="reference external" href="#enable-scheduler-extensions">Enable scheduler extensions</a></p></li>
</ul>
</li>
<li><p><a class="reference external" href="#pmem-csi-deployment-crd">PMEM-CSI Deployment CRD</a></p></li>
<li><p><a class="reference external" href="#filing-issues-and-contributing">Filing issues and contributing</a></p></li>
</ul>
<div class="section" id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<div class="section" id="software-required">
<h3>Software required<a class="headerlink" href="#software-required" title="Permalink to this headline">¶</a></h3>
<p>The recommended mimimum Linux kernel version for running the PMEM-CSI driver is 4.15. See <a class="reference external" href="https://pmem.io/2018/05/15/using_persistent_memory_devices_with_the_linux_device_mapper.html">Persistent Memory Programming</a> for more details about supported kernel versions.</p>
</div>
<div class="section" id="hardware-required">
<h3>Hardware required<a class="headerlink" href="#hardware-required" title="Permalink to this headline">¶</a></h3>
<p>Persistent memory device(s) are required for operation. However, some
development and testing can be done using QEMU-emulated persistent
memory devices. See the <a class="reference external" href="autotest.html#qemu-and-kubernetes">“QEMU and Kubernetes”</a>
section for the commands that create such a virtual test cluster.</p>
</div>
<div class="section" id="persistent-memory-pre-provisioning">
<h3>Persistent memory pre-provisioning<a class="headerlink" href="#persistent-memory-pre-provisioning" title="Permalink to this headline">¶</a></h3>
<p>The PMEM-CSI driver needs pre-provisioned regions on the NVDIMM
device(s). The PMEM-CSI driver itself intentionally leaves that to the
administrator who then can decide how much and how PMEM is to be used
for PMEM-CSI.</p>
<p>Beware that the PMEM-CSI driver will run without errors on a node
where PMEM was not prepared for it. It will then report zero local
storage for that node, something that currently is only visible in the
log files.</p>
<p>When running the Kubernetes cluster and PMEM-CSI on bare metal,
the <a class="reference external" href="https://github.com/intel/ipmctl">ipmctl</a> utility can be used to create regions.
App Direct Mode has two configuration options - interleaved or non-interleaved.
One region per each NVDIMM is created in non-interleaved configuration.
In such a configuration, a PMEM-CSI volume cannot be larger than one NVDIMM.</p>
<p>Example of creating regions without interleaving, using all NVDIMMs:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ipmctl create -goal <span class="nv">PersistentMemoryType</span><span class="o">=</span>AppDirectNotInterleaved
</pre></div>
</div>
<p>Alternatively, multiple NVDIMMs can be combined to form an interleaved set.
This causes the data to be striped over multiple NVDIMM devices
for improved read/write performance and allowing one region (also, PMEM-CSI volume)
to be larger than single NVDIMM.</p>
<p>Example of creating regions in interleaved mode, using all NVDIMMs:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ipmctl create -goal <span class="nv">PersistentMemoryType</span><span class="o">=</span>AppDirect
</pre></div>
</div>
<p>When running inside virtual machines, each virtual machine typically
already gets access to one region and <code class="docutils literal notranslate"><span class="pre">ipmctl</span></code> is not needed inside
the virtual machine. Instead, that region must be made available for
use with PMEM-CSI because when the virtual machine comes up for the
first time, the entire region is already allocated for use as a single
block device:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ndctl list -RN
<span class="go">{</span>
<span class="go">  &quot;regions&quot;:[</span>
<span class="go">    {</span>
<span class="go">      &quot;dev&quot;:&quot;region0&quot;,</span>
<span class="go">      &quot;size&quot;:34357641216,</span>
<span class="go">      &quot;available_size&quot;:0,</span>
<span class="go">      &quot;max_available_extent&quot;:0,</span>
<span class="go">      &quot;type&quot;:&quot;pmem&quot;,</span>
<span class="go">      &quot;persistence_domain&quot;:&quot;unknown&quot;,</span>
<span class="go">      &quot;namespaces&quot;:[</span>
<span class="go">        {</span>
<span class="go">          &quot;dev&quot;:&quot;namespace0.0&quot;,</span>
<span class="go">          &quot;mode&quot;:&quot;raw&quot;,</span>
<span class="go">          &quot;size&quot;:34357641216,</span>
<span class="go">          &quot;sector_size&quot;:512,</span>
<span class="go">          &quot;blockdev&quot;:&quot;pmem0&quot;</span>
<span class="go">        }</span>
<span class="go">      ]</span>
<span class="go">    }</span>
<span class="go">  ]</span>
<span class="go">}</span>
<span class="gp">$</span> ls -l /dev/pmem*
<span class="go">brw-rw---- 1 root disk 259, 0 Jun  4 16:41 /dev/pmem0</span>
</pre></div>
</div>
<p>Labels must be initialized in such a region, which must be performed
once after the first boot:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ndctl disable-region region0
<span class="go">disabled 1 region</span>
<span class="gp">$</span> ndctl init-labels nmem0
<span class="go">initialized 1 nmem</span>
<span class="gp">$</span> ndctl enable-region region0
<span class="go">enabled 1 region</span>
<span class="gp">$</span> ndctl list -RN
<span class="go">[</span>
<span class="go">  {</span>
<span class="go">    &quot;dev&quot;:&quot;region0&quot;,</span>
<span class="go">    &quot;size&quot;:34357641216,</span>
<span class="go">    &quot;available_size&quot;:34357641216,</span>
<span class="go">    &quot;max_available_extent&quot;:34357641216,</span>
<span class="go">    &quot;type&quot;:&quot;pmem&quot;,</span>
<span class="go">    &quot;iset_id&quot;:10248187106440278,</span>
<span class="go">    &quot;persistence_domain&quot;:&quot;unknown&quot;</span>
<span class="go">  }</span>
<span class="go">]</span>
<span class="gp">$</span> ls -l /dev/pmem*
<span class="go">ls: cannot access &#39;/dev/pmem*&#39;: No such file or directory</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="installation-and-setup">
<h2>Installation and setup<a class="headerlink" href="#installation-and-setup" title="Permalink to this headline">¶</a></h2>
<p>This section assumes that a Kubernetes cluster is already available
with at least one node that has persistent memory device(s). For development or
testing, it is also possible to use a cluster that runs on QEMU virtual
machines, see the <a class="reference external" href="autotest.html#qemu-and-kubernetes">“QEMU and Kubernetes”</a>.</p>
<ul class="simple">
<li><p><strong>Make sure that the alpha feature gates CSINodeInfo and CSIDriverRegistry are enabled</strong></p></li>
</ul>
<p>The method to configure alpha feature gates may vary, depending on the Kubernetes deployment.
It may not be necessary anymore when the feature has reached beta state, which depends
on the Kubernetes version.</p>
<ul class="simple">
<li><p><strong>Label the cluster nodes that provide persistent memory device(s)</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl label node &lt;your node&gt; <span class="nv">storage</span><span class="o">=</span>pmem
</pre></div>
</div>
<div class="section" id="install-pmem-csi-driver">
<h3>Install PMEM-CSI driver<a class="headerlink" href="#install-pmem-csi-driver" title="Permalink to this headline">¶</a></h3>
<p>PMEM-CSI driver can be deployed to a Kubernetes cluster either using the
PMEM-CSI operator or by using reference yaml files provided in source code.</p>
<div class="section" id="install-using-the-operator">
<h4>Install using the operator<a class="headerlink" href="#install-using-the-operator" title="Permalink to this headline">¶</a></h4>
<p><a class="reference external" href="./design.html#operator">PMEM-CSI operator</a> facilitates deploying and managing
the <a class="reference external" href="https://github.com/intel/pmem-csi">PMEM-CSI driver</a> on a Kubernetes cluster.</p>
<ul class="simple">
<li><p><strong>Setup deployment certificates</strong></p></li>
</ul>
<p>By default, the operator creates the needed private keys and certificates required
for running the driver as described in <a class="reference external" href="./design.html#security">driver security</a>
section. Those certificates are generated by the operator using a self-signed CA.
This can be overridden with custom keys and certificates by using appropriate fields
in the <a class="reference external" href="#deploymentspec">deployment specification</a>.These encoded certificates and
private keys are made available to driver pods via Kubernetes <a class="reference external" href="https://kubernetes.io/docs/concepts/configuration/secret/">secrets</a>
by the operator.</p>
<p><strong>NOTE:</strong> A production deployment that is not supposed to depend on the
operator’s self-signed CA instead must provide the certificates generated
from a trusted certificate authority.</p>
<ul class="simple">
<li><p><strong>Install the PMEM-CSI operator</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f https://github.com/intel/pmem-csi/raw/devel/deploy/operator/pmem-csi-operator.yaml
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Create a custom resource</strong></p></li>
</ul>
<p>Once the operator deployed in the previous step is in the <code class="docutils literal notranslate"><span class="pre">Running</span></code> state,
it is ready to handle PMEM-CSI <code class="docutils literal notranslate"><span class="pre">Deployment</span></code> objects in the <code class="docutils literal notranslate"><span class="pre">pmem-csi.intel.com</span></code>
API group. Refer to the <a class="reference external" href="#PMEM-CSI-Deployment-CRD">Deployment CRD API</a> for
a complete list of supported properties.</p>
<p>Here is an example driver deployment created with a custom resource:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f - &lt;&lt;EOF
<span class="go">apiVersion: pmem-csi.intel.com/v1alpha1</span>
<span class="go">kind: Deployment</span>
<span class="go">metadata:</span>
<span class="go">  name: pmem-deployment</span>
<span class="go">spec:</span>
<span class="go">  pmemPercentage: 50</span>
<span class="go">  deviceMode: lvm</span>
<span class="go">  controllerResources:</span>
<span class="go">    requests:</span>
<span class="go">      cpu: &quot;200m&quot;</span>
<span class="go">      memory: &quot;100Mi&quot;</span>
<span class="go">  nodeResources:</span>
<span class="go">    requests:</span>
<span class="go">      cpu: &quot;200m&quot;</span>
<span class="go">      memory: &quot;100Mi&quot;</span>
<span class="go">EOF</span>
</pre></div>
</div>
<p>Once the above deployment installation is successful, we can see all the driver
pods in <code class="docutils literal notranslate"><span class="pre">Running</span></code> state:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl get deployments.pmem-csi.intel.com
<span class="go">NAME                 AGE</span>
<span class="go">pmem-deployment      50s</span>

<span class="gp">$</span> kubectl describe deployment.pmem-csi.intel.com pmem-deployment
<span class="go">Name:         pmem-deployment</span>
<span class="go">Namespace:    default</span>
<span class="go">Labels:       &lt;none&gt;</span>
<span class="go">Annotations:  &lt;none&gt;</span>
<span class="go">API Version:  pmem-csi.intel.com/v1alpha1</span>
<span class="go">Kind:         Deployment</span>
<span class="go">Metadata:</span>
<span class="go">  Creation Timestamp:  2020-01-23T13:40:32Z</span>
<span class="go">  Generation:          1</span>
<span class="go">  Resource Version:    3596387</span>
<span class="go">  Self Link:           /apis/pmem-csi.intel.com/v1alpha1/deployments/pmem-deployment</span>
<span class="go">  UID:                 454b5961-5aa2-41c3-b774-29fe932ae236</span>
<span class="go">Spec:</span>
<span class="go">  Controller Resources:</span>
<span class="go">    Requests:</span>
<span class="go">      Cpu:      200m</span>
<span class="go">      Memory:   100Mi</span>
<span class="go">  Device Mode:  lvm</span>
<span class="go">  Image:        localhost/pmem-csi-driver:canary</span>
<span class="go">  Node Resources:</span>
<span class="go">    Requests:</span>
<span class="go">      Cpu:     200m</span>
<span class="go">      Memory:  100Mi</span>
<span class="go">Status:</span>
<span class="go">  Phase:  Running</span>
<span class="go">Events:   &lt;none&gt;</span>


<span class="gp">$</span> kubectl get po
<span class="go">NAME                               READY   STATUS    RESTARTS   AGE</span>
<span class="go">pmem-deployment-controller-0       2/2     Running   0          51s</span>
<span class="go">pmem-deployment-node-4x7cv         2/2     Running   0          50s</span>
<span class="go">pmem-deployment-node-6grt6         2/2     Running   0          50s</span>
<span class="go">pmem-deployment-node-msgds         2/2     Running   0          51s</span>
<span class="go">pmem-csi-operator-749c7c7c69-k5k8n 1/1     Running   0          3m</span>
</pre></div>
</div>
</div>
<div class="section" id="install-from-source">
<h4>Install from source<a class="headerlink" href="#install-from-source" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p><strong>Get source code</strong></p></li>
</ul>
<p>PMEM-CSI uses Go modules and thus can be checked out and (if that should be desired)
built anywhere in the filesystem. Pre-built container images are available and thus
users don’t need to build from source, but they may need some additional files
for the following sections.
To get the source code, use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> git clone https://github.com/intel/pmem-csi
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Set up certificates</strong></p></li>
</ul>
<p>Certificates are required as explained in <a class="reference external" href="design.html#security">Security</a>.
If you are not using the test cluster described in
<a class="reference external" href="autotest.html#starting-and-stopping-a-test-cluster">Starting and stopping a test cluster</a>
where certificates are created automatically, you must set up certificates manually.
This can be done by running the <code class="docutils literal notranslate"><span class="pre">./test/setup-ca-kubernetes.sh</span></code> script for your cluster.
This script requires “cfssl” tools which can be downloaded.
These are the steps for manual set-up of certificates:</p>
<ul class="simple">
<li><p>Download cfssl tools</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o _work/bin/cfssl --create-dirs
<span class="gp">$</span> curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o _work/bin/cfssljson --create-dirs
<span class="gp">$</span> chmod a+x _work/bin/cfssl _work/bin/cfssljson
</pre></div>
</div>
<ul class="simple">
<li><p>Run certificates set-up script</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nv">KUBCONFIG</span><span class="o">=</span><span class="s2">&quot;&lt;&lt;your cluster kubeconfig path&gt;&gt;&quot;</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$PATH</span><span class="s2">:</span><span class="nv">$PWD</span><span class="s2">/_work/bin&quot;</span> ./test/setup-ca-kubernetes.sh
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Deploy the driver to Kubernetes</strong></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">deploy/kubernetes-&lt;kubernetes</span> <span class="pre">version&gt;</span></code> directory contains
<code class="docutils literal notranslate"><span class="pre">pmem-csi*.yaml</span></code> files which can be used to deploy the driver on that
Kubernetes version. The files in the directory with the highest
Kubernetes version might also work for more recent Kubernetes
releases. All of these deployments use images published by Intel on
<a class="reference external" href="https://hub.docker.com/u/intel">Docker Hub</a>.</p>
<p>For each Kubernetes version, four different deployment variants are provided:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">direct</span></code> or <code class="docutils literal notranslate"><span class="pre">lvm</span></code>: one uses direct device mode, the other LVM device mode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">testing</span></code>: the variants with <code class="docutils literal notranslate"><span class="pre">testing</span></code> in the name enable debugging
features and shouldn’t be used in production.</p></li>
</ul>
<p>For example, to deploy for production with LVM device mode onto Kubernetes 1.17, use:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f deploy/kubernetes-1.17/pmem-csi-lvm.yaml
</pre></div>
</div>
<p>The PMEM-CSI <a class="reference external" href="design.html#scheduler-extender">scheduler extender</a> and
<a class="reference external" href="design.html#pod-admission-webhook">webhook</a> are not enabled in this basic
installation. See <a class="reference external" href="#enable-scheduler-extensions">below</a> for
instructions about that.</p>
<p>These variants were generated with
<a class="reference external" href="https://github.com/kubernetes-sigs/kustomize"><code class="docutils literal notranslate"><span class="pre">kustomize</span></code></a>.
<code class="docutils literal notranslate"><span class="pre">kubectl</span></code> &gt;= 1.14 includes some support for that. The sub-directories
of <a class="reference external" href="https://github.com/intel/pmem-csi/tree/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/kustomize">deploy/kustomize</a><code class="docutils literal notranslate"><span class="pre">-&lt;kubernetes</span> <span class="pre">version&gt;</span></code> can be used as bases
for <code class="docutils literal notranslate"><span class="pre">kubectl</span> <span class="pre">kustomize</span></code>. For example:</p>
<ul>
<li><p>Change namespace:</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p my-pmem-csi-deployment
<span class="gp">$</span> cat &gt;my-pmem-csi-deployment/kustomization.yaml &lt;&lt;EOF
<span class="go">namespace: pmem-csi</span>
<span class="go">bases:</span>
<span class="go">  - ../deploy/kubernetes-1.17/lvm</span>
<span class="go">EOF</span>
<span class="gp">$</span> kubectl create namespace pmem-csi
<span class="gp">$</span> kubectl create --kustomize my-pmem-csi-deployment
</pre></div>
</div>
</li>
<li><p>Configure how much PMEM is used by PMEM-CSI for LVM
(see <a class="reference external" href="design.html#namespace-modes-in-lvm-device-mode">Namespace modes in LVM device mode</a>):</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p my-pmem-csi-deployment
<span class="gp">$</span> cat &gt;my-pmem-csi-deployment/kustomization.yaml &lt;&lt;EOF
<span class="go">bases:</span>
<span class="go">  - ../deploy/kubernetes-1.17/lvm</span>
<span class="go">patchesJson6902:</span>
<span class="go">  - target:</span>
<span class="go">      group: apps</span>
<span class="go">      version: v1</span>
<span class="go">      kind: DaemonSet</span>
<span class="go">      name: pmem-csi-node</span>
<span class="go">    path: lvm-parameters-patch.yaml</span>
<span class="go">EOF</span>
<span class="gp">$</span> cat &gt;my-pmem-csi-deployment/lvm-parameters-patch.yaml &lt;&lt;EOF
<span class="gp">#</span> pmem-ns-init is in the init container <span class="c1">#0. Append arguments at the end.</span>
<span class="go">- op: add</span>
<span class="go">  path: /spec/template/spec/initContainers/0/args/-</span>
<span class="go">  value: &quot;--useforfsdax=90&quot;</span>
<span class="go">EOF</span>
<span class="gp">$</span> kubectl create --kustomize my-pmem-csi-deployment
</pre></div>
</div>
</li>
<li><p>Wait until all pods reach ‘Running’ status</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl get pods
<span class="go">NAME                    READY   STATUS    RESTARTS   AGE</span>
<span class="go">pmem-csi-node-8kmxf     2/2     Running   0          3m15s</span>
<span class="go">pmem-csi-node-bvx7m     2/2     Running   0          3m15s</span>
<span class="go">pmem-csi-controller-0   2/2     Running   0          3m15s</span>
<span class="go">pmem-csi-node-fbmpg     2/2     Running   0          3m15s</span>
</pre></div>
</div>
<p>Once after the driver deployed using one of the methods mentioned above
verify that the node labels have been configured correctly</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl get nodes --show-labels
</pre></div>
</div>
<p>The command output must indicate that every node with PMEM has these two labels:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">pmem-csi.intel.com/node=&lt;NODE-NAME&gt;,storage=pmem</span>
</pre></div>
</div>
<p>If <strong>storage=pmem</strong> is missing, label manually as described above. If
<strong>pmem-csi.intel.com/node</strong> is missing, then double-check that the
alpha feature gates are enabled, that the CSI driver is running on the node,
and that the driver’s log output doesn’t contain errors.</p>
<ul class="simple">
<li><p><strong>Define two storage classes using the driver</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f deploy/kubernetes-&lt;kubernetes version&gt;/pmem-storageclass-ext4.yaml
<span class="gp">$</span> kubectl create -f deploy/kubernetes-&lt;kubernetes version&gt;/pmem-storageclass-xfs.yaml
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Provision two pmem-csi volumes</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f deploy/kubernetes-&lt;kubernetes version&gt;/pmem-pvc.yaml
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Verify two Persistent Volume Claims have ‘Bound’ status</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl get pvc
<span class="go">NAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS       AGE</span>
<span class="go">pmem-csi-pvc-ext4   Bound    pvc-f70f7b36-6b36-11e9-bf09-deadbeef0100   4Gi        RWO            pmem-csi-sc-ext4   16s</span>
<span class="go">pmem-csi-pvc-xfs    Bound    pvc-f7101fd2-6b36-11e9-bf09-deadbeef0100   4Gi        RWO            pmem-csi-sc-xfs    16s</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Start two applications requesting one provisioned volume each</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl create -f deploy/kubernetes-&lt;kubernetes version&gt;/pmem-app.yaml
</pre></div>
</div>
<p>These applications use <strong>storage: pmem</strong> in the <i>nodeSelector</i>
list to ensure scheduling to a node supporting pmem device, and each requests a mount of a volume,
one with ext4-format and another with xfs-format file system.</p>
<ul class="simple">
<li><p><strong>Verify two application pods reach ‘Running’ status</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl get po my-csi-app-1 my-csi-app-2
<span class="go">NAME           READY   STATUS    RESTARTS   AGE</span>
<span class="go">my-csi-app-1   1/1     Running   0          6m5s</span>
<span class="go">NAME           READY   STATUS    RESTARTS   AGE</span>
<span class="go">my-csi-app-2   1/1     Running   0          6m1s</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Check that applications have a pmem volume mounted with added dax option</strong></p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl <span class="nb">exec</span> my-csi-app-1 -- df /data
<span class="go">Filesystem           1K-blocks      Used Available Use% Mounted on</span>
<span class="go">/dev/ndbus0region0fsdax/5ccaa889-551d-11e9-a584-928299ac4b17</span>
<span class="go">                       4062912     16376   3820440   0% /data</span>

<span class="gp">$</span> kubectl <span class="nb">exec</span> my-csi-app-2 -- df /data
<span class="go">Filesystem           1K-blocks      Used Available Use% Mounted on</span>
<span class="go">/dev/ndbus0region0fsdax/5cc9b19e-551d-11e9-a584-928299ac4b17</span>
<span class="go">                       4184064     37264   4146800   1% /data</span>

<span class="gp">$</span> kubectl <span class="nb">exec</span> my-csi-app-1 -- mount <span class="p">|</span>grep /data
<span class="go">/dev/ndbus0region0fsdax/5ccaa889-551d-11e9-a584-928299ac4b17 on /data type ext4 (rw,relatime,dax)</span>

<span class="gp">$</span> kubectl <span class="nb">exec</span> my-csi-app-2 -- mount <span class="p">|</span>grep /data
<span class="go">/dev/ndbus0region0fsdax/5cc9b19e-551d-11e9-a584-928299ac4b17 on /data type xfs (rw,relatime,attr2,dax,inode64,noquota)</span>
</pre></div>
</div>
</div>
<div class="section" id="expose-persistent-and-cache-volumes-to-applications">
<h4>Expose persistent and cache volumes to applications<a class="headerlink" href="#expose-persistent-and-cache-volumes-to-applications" title="Permalink to this headline">¶</a></h4>
<p>Kubernetes cluster administrators can expose persistent and cache volumes
to applications using
<a class="reference external" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#parameters"><code class="docutils literal notranslate"><span class="pre">StorageClass</span> <span class="pre">Parameters</span></code></a>. An
optional <code class="docutils literal notranslate"><span class="pre">persistencyModel</span></code> parameter differentiates how the
provisioned volume can be used:</p>
<ul>
<li><p>no <code class="docutils literal notranslate"><span class="pre">persistencyModel</span></code> parameter or <code class="docutils literal notranslate"><span class="pre">persistencyModel:</span> <span class="pre">normal</span></code> in <code class="docutils literal notranslate"><span class="pre">StorageClass</span></code></p>
<p>A normal Kubernetes persistent volume. In this case
PMEM-CSI creates PMEM volume on a node and the application that
claims to use this volume is supposed to be scheduled onto this node
by Kubernetes. Choosing of node is depend on StorageClass
<code class="docutils literal notranslate"><span class="pre">volumeBindingMode</span></code>. In case of <code class="docutils literal notranslate"><span class="pre">volumeBindingMode:</span> <span class="pre">Immediate</span></code>
PMEM-CSI chooses a node randomly, and in case of <code class="docutils literal notranslate"><span class="pre">volumeBindingMode:</span> <span class="pre">WaitForFirstConsumer</span></code> (also known as late binding) Kubernetes first chooses a node for scheduling
the application, and PMEM-CSI creates the volume on that
node. Applications which claim a normal persistent volume has to use
<code class="docutils literal notranslate"><span class="pre">ReadOnlyOnce</span></code> access mode in its <code class="docutils literal notranslate"><span class="pre">accessModes</span></code> list. This
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/docs/images/sequence/pmem-csi-persistent-sequence-diagram.png">diagram</a>
illustrates how a normal persistent volume gets provisioned in
Kubernetes using PMEM-CSI driver.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">persistencyModel:</span> <span class="pre">cache</span></code></p>
<p>Volumes of this type shall be used in combination with
<code class="docutils literal notranslate"><span class="pre">volumeBindingMode:</span> <span class="pre">Immediate</span></code>. In this case, PMEM-CSI creates a set
of PMEM volumes each volume on different node. The number of PMEM
volumes to create can be specified by <code class="docutils literal notranslate"><span class="pre">cacheSize</span></code> StorageClass
parameter. Applications which claim a <code class="docutils literal notranslate"><span class="pre">cache</span></code> volume can use
<code class="docutils literal notranslate"><span class="pre">ReadWriteMany</span></code> in its <code class="docutils literal notranslate"><span class="pre">accessModes</span></code> list. Check with provided
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-storageclass-cache.yaml">cacheStorageClass</a>
example. This
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/docs/images/sequence/pmem-csi-cache-sequence-diagram.png">diagram</a>
illustrates how a cache volume gets provisioned in Kubernetes using
PMEM-CSI driver.</p>
</li>
</ul>
<p><strong>NOTE</strong>: Cache volumes are associated with a node, not a pod. Multiple
pods using the same cache volume on the same node will not get their
own instance but will end up sharing the same PMEM volume instead.
Application deployment has to consider this and use available Kubernetes
mechanisms like <a class="reference external" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity">node
anti-affinity</a>.
Check with the provided
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-app-cache.yaml">cacheapplication</a> example.</p>
<p><strong>WARNING</strong>: late binding (<code class="docutils literal notranslate"><span class="pre">volumeBindingMode:WaitForFirstConsume</span></code>) has some caveats:</p>
<ul class="simple">
<li><p>Pod creation may get stuck when there isn’t enough capacity left for
the volumes; see the next section for details.</p></li>
<li><p>A node is only chosen the first time a pod starts. After that it will always restart
on that node, because that is where the persistent volume was created.</p></li>
</ul>
</div>
</div>
<div class="section" id="kata-containers-support">
<h3>Kata Containers support<a class="headerlink" href="#kata-containers-support" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="design.html#kata-containers-support">Kata Containers support</a> gets enabled via
the <code class="docutils literal notranslate"><span class="pre">kataContainers</span></code> storage class parameter. It accepts the following
values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">true/1/t/TRUE</span></code><br />Create the filesystem inside a partition inside a file, try to mount
on the host through a loop device with <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">dax</span></code> but proceed without
<code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">dax</span></code> when the kernel does not support that. Currently Linux up
to and including 5.4 do not support it. In other words, on the host
such volumes are usable, but only without DAX. Inside Kata
Containers, DAX works.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">false/0/f/FALSE</span></code> (default)<br />Create the filesystem directly on the volume.</p></li>
</ul>
<p><a class="reference external" href="#raw-block-volumes">Raw block volumes</a> are only supported with
<code class="docutils literal notranslate"><span class="pre">kataContainers:</span> <span class="pre">false</span></code>. Attempts to create them with <code class="docutils literal notranslate"><span class="pre">kataContainers:</span> <span class="pre">true</span></code> are rejected.</p>
<p>At the moment (= Kata Containers 1.11.0-rc0), only Kata Containers
with QEMU enable the special support for such volumes. Without QEMU or
with older releases of Kata Containers, the volume is still usable
through the normal remote filesystem support (9p or virtio-fs). Support
for Cloud Hypervisor is <a class="reference external" href="https://github.com/kata-containers/runtime/issues/2575">in
progress</a>.</p>
<p>With Kata Containers for QEMU, the VM must be configured appropriately
to allow adding the PMEM volumes to their address space. This can be
done globally by setting the <code class="docutils literal notranslate"><span class="pre">memory_offset</span></code> in the
<a class="reference external" href="https://github.com/kata-containers/runtime/blob/ee985a608015d81772901c1d9999190495fc9a0a/cli/config/configuration-qemu.toml.in#L86-L91"><code class="docutils literal notranslate"><span class="pre">configuration-qemu.toml</span></code>
file</a>
or per-pod by setting the
<a class="reference external" href="https://github.com/kata-containers/documentation/blob/master/how-to/how-to-set-sandbox-config-kata.md#hypervisor-options"><code class="docutils literal notranslate"><span class="pre">io.katacontainers.config.hypervisor.memory_offset</span></code>
label</a>
in the pod meta data. In both cases, the value has to be large enough
for all PMEM volumes used by the pod, otherwise pod creation will fail
with an error similar to this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Error: container create failed: QMP command failed: not enough space, currently 0x8000000 in use of total space for memory devices 0x3c100000</span>
</pre></div>
</div>
<p>The examples for usage of Kata Containers <a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-kata-app-ephemeral.yaml">with
ephemeral</a> and
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-kata-app.yaml">persistent</a> volumes use the pod
label. They assume that the <code class="docutils literal notranslate"><span class="pre">kata-qemu</span></code> runtime class <a class="reference external" href="https://github.com/kata-containers/packaging/tree/1.11.0-rc0/kata-deploy#run-a-sample-workload">is
installed</a>.</p>
<p>For the QEMU test cluster,
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/test/setup-kata-containers.sh"><code class="docutils literal notranslate"><span class="pre">setup-kata-containers.sh</span></code></a> can be
used to install Kata Containers. However, this currently only works on
Clear Linux because on Fedora, the Docker container runtime is used
and Kata Containers does not support that one.</p>
</div>
<div class="section" id="ephemeral-inline-volumes">
<h3>Ephemeral inline volumes<a class="headerlink" href="#ephemeral-inline-volumes" title="Permalink to this headline">¶</a></h3>
<p>Volume requests <a class="reference external" href="https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html#example-of-inline-csi-pod-spec">embedded in the pod spec</a> are provisioned as
ephemeral volumes. The volume request could use below fields as
<a class="reference external" href="https://kubernetes.io/docs/concepts/storage/volumes/#csi"><code class="docutils literal notranslate"><span class="pre">volumeAttributes</span></code></a>:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>key</th>
<th>meaning</th>
<th>optional</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size</code></td>
<td>Size of the requested ephemeral volume as <a href="https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#meaning-of-memory">Kubernetes memory string</a> ("1Mi" = 1024*1024 bytes, "1e3K = 1000000 bytes)</td>
<td>No</td>
<td></td>
</tr>
<tr>
<td><code>eraseAfter</code></td>
<td>Clear all data after use and before<br> deleting the volume</td>
<td>Yes</td>
<td><code>true</code> (default),<br> <code>false</code></td>
</tr>
<tr>
<td><code>kataContainers</code></td>
<td>Prepare volume for use in Kata Containers.</td>
<td>Yes</td>
<td><code>false/0/f/FALSE</code> (default),<br> <code>true/1/t/TRUE</code></td>
</tr>
</tbody>
</table><p>Check with provided <a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/kubernetes-1.15/pmem-app-ephemeral.yaml">example application</a> for
ephemeral volume usage.</p>
<div class="section" id="raw-block-volumes">
<h4>Raw block volumes<a class="headerlink" href="#raw-block-volumes" title="Permalink to this headline">¶</a></h4>
<p>Applications can use volumes provisioned by PMEM-CSI as <a class="reference external" href="https://kubernetes.io/blog/2019/03/07/raw-block-volume-support-to-beta/">raw block
devices</a>. Such
volumes use the same “fsdax” namespace mode as filesystem volumes
and therefore are block devices. That mode only supports dax (=
<code class="docutils literal notranslate"><span class="pre">mmap(MAP_SYNC)</span></code>) through a filesystem. Pages mapped on the raw block
device go through the Linux page cache. Applications have to format
and mount the raw block volume themselves if they want dax. The
advantage then is that they have full control over that part.</p>
<p>For provisioning a PMEM volume as raw block device, one has to create a
<code class="docutils literal notranslate"><span class="pre">PersistentVolumeClaim</span></code> with <code class="docutils literal notranslate"><span class="pre">volumeMode:</span> <span class="pre">Block</span></code>. See example <a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-pvc-block-volume.yaml">PVC</a> and
<a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/common/pmem-app-block-volume.yaml">application</a> for usage reference.</p>
<p>That example demonstrates how to handle some details:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mkfs.ext4</span></code> needs <code class="docutils literal notranslate"><span class="pre">-b</span> <span class="pre">4096</span></code> to produce volumes that support dax;
without it, the automatic block size detection may end up choosing
an unsuitable value depending on the volume size.</p></li>
<li><p><a class="reference external" href="https://github.com/kubernetes/kubernetes/issues/85624">Kubernetes bug #85624</a>
must be worked around to format and mount the raw block device.</p></li>
</ul>
</div>
<div class="section" id="enable-scheduler-extensions">
<h4>Enable scheduler extensions<a class="headerlink" href="#enable-scheduler-extensions" title="Permalink to this headline">¶</a></h4>
<p>The PMEM-CSI scheduler extender and admission webhook are provided by
the PMEM-CSI controller. They need to be enabled during deployment via
the <code class="docutils literal notranslate"><span class="pre">--schedulerListen=[&lt;listen</span> <span class="pre">address&gt;]:&lt;port&gt;</span></code> parameter. The
listen address is optional and can be left out. The port is where a
HTTPS server will run. It uses the same certificates as the internal
gRPC service. When using the CA creation script described above, they
will contain alternative names for the URLs described in this section
(service names, <code class="docutils literal notranslate"><span class="pre">127.0.0.1</span></code> IP address).</p>
<p>This parameter can be added to one of the existing deployment files
with <code class="docutils literal notranslate"><span class="pre">kustomize</span></code>. All of the following examples assume that the
current directory contains the <code class="docutils literal notranslate"><span class="pre">deploy</span></code> directory from the PMEM-CSI
repository. It is also possible to reference the base via a
<a class="reference external" href="https://github.com/kubernetes-sigs/kustomize/blob/master/examples/remoteBuild">URL</a>.</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir my-pmem-csi-deployment

<span class="gp">$</span> cat &gt;my-pmem-csi-deployment/kustomization.yaml &lt;&lt;EOF
<span class="go">bases:</span>
<span class="go">  - ../deploy/kubernetes-1.16/lvm</span>
<span class="go">patchesJson6902:</span>
<span class="go">  - target:</span>
<span class="go">      group: apps</span>
<span class="go">      version: v1</span>
<span class="go">      kind: StatefulSet</span>
<span class="go">      name: pmem-csi-controller</span>
<span class="go">    path: scheduler-patch.yaml</span>
<span class="go">EOF</span>

<span class="gp">$</span> cat &gt;my-pmem-csi-deployment/scheduler-patch.yaml &lt;&lt;EOF
<span class="go">- op: add</span>
<span class="go">  path: /spec/template/spec/containers/0/command/-</span>
<span class="go">  value: &quot;--schedulerListen=:8000&quot;</span>
<span class="go">EOF</span>

<span class="gp">$</span> kubectl create --kustomize my-pmem-csi-deployment
</pre></div>
</div>
<p>To enable the PMEM-CSI scheduler extender, a configuration file and an
additional <code class="docutils literal notranslate"><span class="pre">--config</span></code> parameter for <code class="docutils literal notranslate"><span class="pre">kube-scheduler</span></code> must be added to
the cluster control plane, or, if there is already such a
configuration file, one new entry must be added to the <code class="docutils literal notranslate"><span class="pre">extenders</span></code>
array. A full example is presented below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">kube-scheduler</span></code> must be able to connect to the PMEM-CSI
controller via the <code class="docutils literal notranslate"><span class="pre">urlPrefix</span></code> in its configuration. In some clusters
it is possible to use cluster DNS and thus a symbolic service name. If
that is the case, then deploy the <a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/kustomize/scheduler/scheduler-service.yaml">scheduler
service</a> as-is
and use <code class="docutils literal notranslate"><span class="pre">https://pmem-csi-scheduler.default.svc</span></code> as <code class="docutils literal notranslate"><span class="pre">urlPrefix</span></code>. If
the PMEM-CSI driver is deployed in a namespace, replace <code class="docutils literal notranslate"><span class="pre">default</span></code> with
the name of that namespace.</p>
<p>In a cluster created with kubeadm, <code class="docutils literal notranslate"><span class="pre">kube-scheduler</span></code> is unable to use
cluster DNS because the pod it runs in is configured with
<code class="docutils literal notranslate"><span class="pre">hostNetwork:</span> <span class="pre">true</span></code> and without <code class="docutils literal notranslate"><span class="pre">dnsPolicy</span></code>. Therefore the cluster DNS
servers are ignored. There also is no special dialer as in other
clusters. As a workaround, the PMEM-CSI service can be exposed via a
fixed node port like 32000 on all nodes. Then
<code class="docutils literal notranslate"><span class="pre">https://127.0.0.1:32000</span></code> needs to be used as <code class="docutils literal notranslate"><span class="pre">urlPrefix</span></code>. Here’s how
the service can be created with that node port:</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir my-scheduler

<span class="gp">$</span> cat &gt;my-scheduler/kustomization.yaml &lt;&lt;EOF
<span class="go">bases:</span>
<span class="go">  - ../deploy/kustomize/scheduler</span>
<span class="go">patchesJson6902:</span>
<span class="go">  - target:</span>
<span class="go">      version: v1</span>
<span class="go">      kind: Service</span>
<span class="go">      name: pmem-csi-scheduler</span>
<span class="go">    path: node-port-patch.yaml</span>
<span class="go">EOF</span>

<span class="gp">$</span> cat &gt;my-scheduler/node-port-patch.yaml &lt;&lt;EOF
<span class="go">- op: add</span>
<span class="go">  path: /spec/ports/0/nodePort</span>
<span class="go">  value: 32000</span>
<span class="go">EOF</span>

<span class="gp">$</span> kubectl create --kustomize my-scheduler
</pre></div>
</div>
<p>How to (re)configure <code class="docutils literal notranslate"><span class="pre">kube-scheduler</span></code> depends on the cluster. With
kubeadm it is possible to set all necessary options in advance before
creating the master node with <code class="docutils literal notranslate"><span class="pre">kubeadm</span> <span class="pre">init</span></code>. One additional
complication with kubeadm is that <code class="docutils literal notranslate"><span class="pre">kube-scheduler</span></code> by default doesn’t
trust any root CA. The following kubeadm config file solves
this together with enabling the scheduler configuration by
bind-mounting the root certificate that was used to sign the certificate used
by the scheduler extender into the location where the Go
runtime will find it:</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo mkdir -p /var/lib/scheduler/
<span class="gp">$</span> sudo cp _work/pmem-ca/ca.pem /var/lib/scheduler/ca.crt

<span class="gp">$</span> sudo sh -c <span class="s1">&#39;cat &gt;/var/lib/scheduler/scheduler-policy.cfg&#39;</span> &lt;&lt;EOF
<span class="go">{</span>
<span class="go">  &quot;kind&quot; : &quot;Policy&quot;,</span>
<span class="go">  &quot;apiVersion&quot; : &quot;v1&quot;,</span>
<span class="go">  &quot;extenders&quot; :</span>
<span class="go">    [{</span>
<span class="go">      &quot;urlPrefix&quot;: &quot;https://&lt;service name or IP&gt;:&lt;port&gt;&quot;,</span>
<span class="go">      &quot;filterVerb&quot;: &quot;filter&quot;,</span>
<span class="go">      &quot;prioritizeVerb&quot;: &quot;prioritize&quot;,</span>
<span class="go">      &quot;nodeCacheCapable&quot;: false,</span>
<span class="go">      &quot;weight&quot;: 1,</span>
<span class="go">      &quot;managedResources&quot;:</span>
<span class="go">      [{</span>
<span class="go">        &quot;name&quot;: &quot;pmem-csi.intel.com/scheduler&quot;,</span>
<span class="go">        &quot;ignoredByScheduler&quot;: true</span>
<span class="go">      }]</span>
<span class="go">    }]</span>
<span class="go">}</span>
<span class="go">EOF</span>

<span class="gp">$</span> cat &gt;kubeadm.config &lt;&lt;EOF
<span class="go">apiVersion: kubeadm.k8s.io/v1beta1</span>
<span class="go">kind: ClusterConfiguration</span>
<span class="go">scheduler:</span>
<span class="go">  extraVolumes:</span>
<span class="go">    - name: config</span>
<span class="go">      hostPath: /var/lib/scheduler</span>
<span class="go">      mountPath: /var/lib/scheduler</span>
<span class="go">      readOnly: true</span>
<span class="go">    - name: cluster-root-ca</span>
<span class="go">      hostPath: /var/lib/scheduler/ca.crt</span>
<span class="go">      mountPath: /etc/ssl/certs/ca.crt</span>
<span class="go">      readOnly: true</span>
<span class="go">  extraArgs:</span>
<span class="go">    config: /var/lib/scheduler/scheduler-config.yaml</span>
<span class="go">EOF</span>

<span class="gp">$</span> kubeadm init --config<span class="o">=</span>kubeadm.config
</pre></div>
</div>
<p>It is possible to stop here without enabling the pod admission webhook.
To enable also that, continue as follows.</p>
<p>First of all, it is recommended to exclude all system pods from
passing through the web hook. This ensures that they can still be
created even when PMEM-CSI is down:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> kubectl label ns kube-system pmem-csi.intel.com/webhook<span class="o">=</span>ignore
</pre></div>
</div>
<p>This special label is configured in <a class="reference external" href="https://github.com/intel/pmem-csi/blob/a68bff506c44c5fc5d759f8b3303cdc2d36c80e4/deploy/kustomize/webhook/webhook.yaml">the provided web hook
definition</a>. On Kubernetes &gt;=
1.15, it can also be used to let individual pods bypass the webhook by
adding that label. The CA gets configured explicitly, which is
supported for webhooks.</p>
<div class="highlight-ShellSession notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir my-webhook

<span class="gp">$</span> cat &gt;my-webhook/kustomization.yaml &lt;&lt;EOF
<span class="go">bases:</span>
<span class="go">  - ../deploy/kustomize/webhook</span>
<span class="go">patchesJson6902:</span>
<span class="go">  - target:</span>
<span class="go">      group: admissionregistration.k8s.io</span>
<span class="go">      version: v1beta1</span>
<span class="go">      kind: MutatingWebhookConfiguration</span>
<span class="go">      name: pmem-csi-hook</span>
<span class="go">    path: webhook-patch.yaml</span>
<span class="go">EOF</span>

<span class="gp">$</span> cat &gt;my-webhook/webhook-patch.yaml &lt;&lt;EOF
<span class="go">- op: replace</span>
<span class="go">  path: /webhooks/0/clientConfig/caBundle</span>
<span class="go">  value: $(base64 -w 0 _work/pmem-ca/ca.pem)</span>
<span class="go">EOF</span>

<span class="gp">$</span> kubectl create --kustomize my-webhook
</pre></div>
</div>
<!-- FILL TEMPLATE:

  ### How to extend the plugin

You can modify PMEM-CSI to support more xxx by changing the `variable` from Y to Z.


  ## Maintenance

* Known limitations
* What is supported and what isn't supported
    * Disclaimer that nothing is supported with any kind of SLA
* Example configuration for target use case
* How to upgrade
* Upgrade cadence


  ## Troubleshooting

* If you see this error, then enter this command `blah`.
--></div>
</div>
</div>
<div class="section" id="pmem-csi-deployment-crd">
<h2>PMEM-CSI Deployment CRD<a class="headerlink" href="#pmem-csi-deployment-crd" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Deployment</span></code> is a cluster-scoped Kubernetes resource in the
<code class="docutils literal notranslate"><span class="pre">pmem-csi.intel.com</span></code> API group. It describes how a PMEM-CSI driver
instance is to be created.</p>
<p>The operator will create objects in the namespace in which the
operator itself runs if the object type is namespaced.</p>
<p>The name of the deployment object is also used as CSI driver
name. This ensures that the name is unique and immutable. However,
name clashes with other CSI drivers are still possible, so the name
should meet the <a class="reference external" href="https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo">CSI
requirements</a>:</p>
<ul class="simple">
<li><p>domain name notation format, including a unique top-level domain</p></li>
<li><p>63 characters or less, beginning and ending with an alphanumeric
character ([a-z0-9A-Z]) with dashes (-), dots (.), and
alphanumerics between.</p></li>
</ul>
<p>The name is also used as prefix for the names of all objects created
for the deployment and for the local <code class="docutils literal notranslate"><span class="pre">/var/lib/&lt;name&gt;</span></code> state directory
on each node.</p>
<p>The current API for PMEM-CSI <code class="docutils literal notranslate"><span class="pre">Deployment</span></code> resources is:</p>
<div class="section" id="deployment">
<h3>Deployment<a class="headerlink" href="#deployment" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>Field</th>
<th>type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>apiVersion</td>
<td>string</td>
<td><code>pmem-csi.intel.com/v1alpha1</code></td>
</tr>
<tr>
<td>kind</td>
<td>string</td>
<td><code>Deployment</code></td>
</tr>
<tr>
<td>metadata</td>
<td><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata">ObjectMeta</a></td>
<td>Object metadata, name used for CSI driver and as prefix for sub-objects</td>
</tr>
<tr>
<td>spec</td>
<td><a href="#deployment-spec">DeploymentSpec</a></td>
<td>Specification of the desired behavior of the deployment</td>
</tr>
</tbody>
</table><div class="section" id="deploymentspec">
<h4>DeploymentSpec<a class="headerlink" href="#deploymentspec" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<thead>
<tr>
<th>Field</th>
<th>type</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>image</td>
<td>string</td>
<td>PMEM-CSI docker image name used for the deployment</td>
<td>the same image as the operator<sup>1</sup></td>
</tr>
<tr>
<td>provisionerImage</td>
<td>string</td>
<td><a href="https://kubernetes-csi.github.io/docs/external-provisioner.html">CSI provisioner</a> docker image name</td>
<td>latest <a href="https://kubernetes-csi.github.io/docs/external-provisioner.html">external provisioner</a> stable release image<sup>2</sup></td>
</tr>
<tr>
<td>registrarImage</td>
<td>string</td>
<td><a href="https://github.com/kubernetes-csi/node-driver-registrar">CSI node driver registrar</a> docker image name</td>
<td>latest <a href="https://kubernetes-csi.github.io/docs/node-driver-registrar.html">node driver registrar</a> stable release image<sup>2</sup></td>
</tr>
<tr>
<td>pullPolicy</td>
<td>string</td>
<td>Docker image pull policy. either one of <code>Always</code>, <code>Never</code>, <code>IfNotPresent</code></td>
<td><code>IfNotPresent</code></td>
</tr>
<tr>
<td>logLevel</td>
<td>integer</td>
<td>PMEM-CSI driver logging level</td>
<td>3</td>
</tr>
<tr>
<td>deviceMode</td>
<td>string</td>
<td>Device management mode to use. Supports one of <code>lvm</code> or <code>direct</code></td>
<td><code>lvm</code></td>
</tr>
<tr>
<td>controllerResources</td>
<td><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#resourcerequirements-v1-core">ResourceRequirements</a></td>
<td>Describes the compute resource requirements for controller pod</td>
<td></td>
</tr>
<tr>
<td>nodeResources</td>
<td><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#resourcerequirements-v1-core">ResourceRequirements</a></td>
<td>Describes the compute resource requirements for the pods running on node(s)</td>
<td></td>
</tr>
<tr>
<td>registryCert</td>
<td>string</td>
<td>Encoded tls certificate signed by a certificate authority used for driver's controller registry server</td>
<td>generated by operator self-signed CA</td>
</tr>
<tr>
<td>nodeControllerCert</td>
<td>string</td>
<td>Encoded tls certificate signed by a certificate authority used for driver's node controllers</td>
<td>generated by operator self-signed CA</td>
</tr>
<tr>
<td>registryKey</td>
<td>string</td>
<td>Encoded RSA private key used for signing by <code>registryCert</code></td>
<td>generated by the operator</td>
</tr>
<tr>
<td>nodeControllerKey</td>
<td>string</td>
<td>Encoded RSA private key used for signing by <code>nodeControllerCert</code></td>
<td>generated by the operator</td>
</tr>
<tr>
<td>caCert</td>
<td>string</td>
<td>Certificate of the CA by which the <code>registryCert</code> and <code>controllerCert</code> are signed</td>
<td>self-signed certificate generated by the operator</td>
</tr>
<tr>
<td>nodeSelector</td>
<td>string map</td>
<td><a href="../docs/install.md#run-pmem-csi-on-kubernetes">Labels to use for selecting Nodes</a> on which PMEM-CSI driver should run.</td>
<td><code>{ "storage": "pmem" }</code></td>
</tr>
<tr>
<td>pmemPercentage</td>
<td>integer</td>
<td>Percentage of PMEM space to be used by the driver on each node. This is only valid for a driver deployed in <code>lvm</code> mode. This field can be modified, but by that time the old value may have been used already. Reducing the percentage is not supported.</td>
<td>100</td>
</tr>
<tr>
<td>labels</td>
<td>string map</td>
<td>Additional labels for all objects created by the operator. Can be modified after the initial creation, but removed labels will not be removed from existing objects because the operator cannot know which labels it needs to remove and which it has to leave in place.</td>
<td></td>
</tr>
</tbody>
</table><p><sup>1</sup> To use the same container image as default driver image
the operator pod must set with below environment variables with
appropriate values:</p>
<ul class="simple">
<li><p>POD_NAME: Name of the operator pod. Namespace of the pod could be figured out by the operator.</p></li>
<li><p>OPERATOR_NAME: Name of the operator container. If not set, defaults to “pmem-csi-operator”</p></li>
</ul>
<p><sup>2</sup> Image versions depend on the Kubernetes release. The
operator dynamically chooses suitable image versions. Users have to
take care of that themselves when overriding the values.</p>
<p><strong>WARNING</strong>: although all fields can be modified and changes will be
propagated to the deployed driver, not all changes are safe. In
particular, changing the <code class="docutils literal notranslate"><span class="pre">deviceMode</span></code> will not work when there are
active volumes.</p>
</div>
<div class="section" id="deploymentstatus">
<h4>DeploymentStatus<a class="headerlink" href="#deploymentstatus" title="Permalink to this headline">¶</a></h4>
<p>A PMEM-CSI Deployment’s <code class="docutils literal notranslate"><span class="pre">status</span></code> field is a <code class="docutils literal notranslate"><span class="pre">DeploymentStatus</span></code> object, which has
a <code class="docutils literal notranslate"><span class="pre">phase</span></code> field. The phase of a Deployment is high-level summary of where the
Deployment is in it’s lifecycle.</p>
<p>The possible <code class="docutils literal notranslate"><span class="pre">phase</span></code> values and their meaning are as below:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty string</td>
<td>A new deployment.</td>
</tr>
<tr>
<td>Initializing</td>
<td>All the direct sub-resources of the <code>Deployment</code> are created, but some indirect ones (like pods controlled by a daemon set) may still be missing.</td>
</tr>
<tr>
<td>Running</td>
<td>The operator has determined that the driver is usable<sup>1</sup>.</td>
</tr>
<tr>
<td>Failed</td>
<td>For some reason the state of the <code>Deployment</code> failed and cannot be progressed<sup>2</sup>.</td>
</tr>
</tbody>
</table><p><sup>1</sup> This check has not been implemented yet. Instead, the deployment goes straight to <code class="docutils literal notranslate"><span class="pre">Running</span></code> after creating sub-resources.
<sup>2</sup> Failure reason is supposed to be carried by one of additional <code class="docutils literal notranslate"><span class="pre">DeploymentStatus</span></code> field, but not implemented yet.</p>
<blockquote>
<div><p><strong>Note on multiple deployments</strong></p>
<p>Though the operator allows running multiple PMEM-CSI driver deployments, one
has to take extreme care of such deployments by ensuring that not more than
one driver ends up running on the same node(s). Nodes on which a PMEM-CSI
driver could run can be configured by using <code class="docutils literal notranslate"><span class="pre">nodeSelector</span></code> property of
<a class="reference external" href="#deployment-crd-api"><code class="docutils literal notranslate"><span class="pre">DeploymentSpec</span></code></a>.</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="filing-issues-and-contributing">
<h2>Filing issues and contributing<a class="headerlink" href="#filing-issues-and-contributing" title="Permalink to this headline">¶</a></h2>
<p>Report a bug by <a class="reference external" href="https://github.com/intel/pmem-csi/issues">filing a new issue</a>.</p>
<p>Before making your first contribution, be sure to read the <a class="reference internal" href="DEVELOPMENT.html"><span class="doc">development documentation</span></a>
for guidance on code quality and branches.</p>
<p>Contribute by <a class="reference external" href="https://github.com/intel/pmem-csi/pulls">opening a pull request</a>.</p>
<p>Learn <a class="reference external" href="https://help.github.com/articles/using-pull-requests/">about pull requests</a>.</p>
<p><strong>Reporting a Potential Security Vulnerability:</strong> If you have discovered potential security vulnerability in PMEM-CSI, please send an e-mail to secure&#64;intel.com. For issues related to Intel Products, please visit <a class="reference external" href="https://security-center.intel.com">Intel Security Center</a>.</p>
<p>It is important to include the following details:</p>
<ul class="simple">
<li><p>The projects and versions affected</p></li>
<li><p>Detailed description of the vulnerability</p></li>
<li><p>Information on known exploits</p></li>
</ul>
<p>Vulnerability information is extremely sensitive. Please encrypt all security vulnerability reports using our <a class="reference external" href="https://www.intel.com/content/www/us/en/security-center/pgp-public-key.html">PGP key</a>.</p>
<p>A member of the Intel Product Security Team will review your e-mail and contact you to collaborate on resolving the issue. For more information on how Intel works to resolve security issues, see: <a class="reference external" href="https://www.intel.com/content/www/us/en/security-center/vulnerability-handling-guidelines.html">vulnerability handling guidelines</a>.</p>
<!-- FILL TEMPLATE:
Contact the development team (*TBD: slack or email?*)


  ## References

Pointers to other useful documentation.

* Video tutorial
    * Simple youtube style. Demo installation following steps in readme.
      Useful to show relevant paths. Helps with troubleshooting.
--></div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DEVELOPMENT.html" class="btn btn-neutral float-right" title="Develop and contribute" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="design.html" class="btn btn-neutral float-left" title="Design and architecture" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019,

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>